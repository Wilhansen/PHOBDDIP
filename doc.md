# OBD Data Interchange Protocol
Updated: 2017.06.08

Author: Wilhansen Li
<!--TOC-->

## General principles

1. Minimize data consumption.
2. Keep security in mind.
3. Structured data formats.

## Overview
1. Limit everything to 1 MTU (576 bytes).
2. Utilize binary formats, [protobuf3](https://developers.google.com/protocol-buffers/docs/proto3) in particular.
3. Utilize [libsodium](https://download.libsodium.org) library for cryptography (the protocol currently requires libsodium 1.0.12+).
4. Use UDP for high frequency data, HTTP for file transfers.
5. Byte order for non-protobuf entries is Little Endian.

### Key Generation and Exchange Algorithm
There are 3 sets of key pairs owned/generated by each party:
1. The _signing_ key pair. Use `crypto_sign_keypair` to generate them.
2. The _encryption_ key pair derived from the signing key pair. Use `crypto_sign_ed25519_pk_to_curve25519` to convert the public key and `crypto_sign_ed25519_sk_to_curve25519` to convert the secret key.
3. The reception and transmission _session_ keys derived from the encryption key pair of the curent party and the public encryption key of the other party. Use `crypto_kx_server_session_keys` or `crypto_kx_client_session_keys` to derive the session keys.

The key exchange is done upon the registration of the device prior to usage.

1. The server has a _signing_ pair, the server's public signing key is available to everyone.
2. Upon registration, the client should generate a _signing_ key pair (using `crypto_sign_keypair`) and give only its public signing key to the server. The signing key pair should be stored securely in the device.
3. For clients, session keys are generated upon startup of the client and stored in secure memory. For the server, the session keys may be generated upon first connection to the client and may be cached for performance.

## Message Protocol

Message payload between client and server is in protobuf3 binary format with a header describing the payload.

All payloads are protobuf3-encoded decryptable using the reception key from the Key Exchange Algorithm with the `crypto_secretbox_*` method in libsodium.

### Client to Server
All messages from client to server are prepended with the following header:
```cpp
struct ClientMessageHeader {
	uint8_t marker[4];
	uint8_t version;
	MessageType message_type;
	uint32_t server_id;
	uint64_t vessel_id;
	PayloadHeader payload_header;
};
```

* `marker` — Always set to the string "OBDI".
* `version` — currently at 0.
* `server_id` — 4-byte ID of the server.
* `vessel_id` — 8-byte ID of the vessel.
* `message_type` — Message type ID, see "Messages" for the list of possible messages.

### Server to Client
All messages from server to client are prepended with the following header:
```cpp
struct ServerMessageHeader {
	uint8_t marker[4];
	uint8_t version;
	MessageType message_type;
	uint32_t server_id;
	PayloadHeader payload_header;
};
```

* `marker` — Always set to the string "OBDI".
* `version` — currently at 0.
* `message_type` — Message type ID, see "Messages" for the list of possible messages. Server responses start with 50 onwards.
* `server_id` — 4-byte ID of the server.

### Payload Header
The `payload_header` is as follows:
```
#define NONCE_SIZE 24 // = crypto_secretbox_NONCEBYTES
#define MAC_SIZE 16 // = crypto_secretbox_MACBYTES
#define RESERVE_SIZE 24
#define SIGNATURE_SIZE 64 // = crypto_sign_BYTES

struct PayloadHeader {
	uint16_t payload_size;
	union {
		struct {
			uint8_t nonce[NONCE_SIZE];
			uint8_t mac[MAC_SIZE];
			uint8_t reserved[RESERVE_SIZE];
		};
		uint8_t signature[SIGNATURE_SIZE];
	};
};
```

* `payload_size` — size of the payload data, in bytes. When parsing, make sure that this is less than  `total_packet_size - `total_header_size`.
* `nonce` — Nonce used for encryption/decryption, when generating messages, fill this with random data.
* `mac` — MAC used to verify whether the decrypted data is correct.
* `signature` — Used if the payload is unencrypted. This contains the signature of the message that can be verified using the originator's public signing key (use `crypto_sign_*` functions).

## Messages
Numbers in square brackets are the message type IDs.

Messages listed below with an asterisk (`*`) have to be sent reliably; they have "response" counterparts. These have a `message_id` field for tracking and response messages should use the same `message_id` as the original message it is responding to.

The value of the `message_id` does not matter as long as it is 1) not zero and 2) unique for all reliable message within a day. One way to implement the distribution of `message_id` is to keep a global message_id counter which increments everytime a message is constructed (i.e. `current_message.message_id = message_id_counter++`). A zero-valued `message_id` is an invalid `message_id`.

The sender algorithm is as follows:

```Swift
let timeouts = [3, 3, 5, 5, 10, 15, 20, 25, 30, 30];
var msg = create_message();
msg.message_id = message_id_counter++;
var try_count = 0;

send(destination: target, message: msg);

while( try_count < 10 ) {
	let response = recieve(from: target, withID: msg.id, timeout: timeouts[try_count]);
	if (response.status == ERROR_TIMEOUT) {
		try_count++;
	} else {
		success();
	}
}
fail();
```

The receiver algorithm is as follows
```Swift
var tracker = Map<int32, Timestamp>();
var packet = listen();

if ( !tracker.contains(packet.message.message_id) ||
	Timestame.now() - tracker[packet.message.message_id] >= 1.day ) {
	message_id_tracker[packet.message.message_id] = Timestamp.now();
	execute(message: packet.message);
}
let response = create_response(for: packet.message);
send(response, to: packet.source);
```
Make sure to purge the `tracker` regularly (if the program is long-running) to prevent overconsumption of memory.

### Common

#### Enums
```protobuf
enum Severity {
	DEBUG = 0;
	INFO = 1;
	WARNING = 2;
	SYSTEM_ERROR = 3;
	MECHANICAL_FAILURE = 4;
	ACCIDENT = 5;
	ENVIRONMENT = 6;
}
```
Error code indicating the severity of the notice:
* `DEBUG` — Debugging message, may be safely ignored in production.
* `INFO` — Informational message that does not correspond to any form of error.
* `WARNING` — Non-fatal on-board device error. Source of the warning may be fixed at a latter date.
* `SYSTEM_ERROR` — Irrecoverable on-board device error. The on-board device should be inspected as soon as possible.
* `MECHANICAL_FAILURE` — The vessel (not just the on-board device) has experienced a mechanical failure.
* `ACCIDENT` — The vessel is caught in accident.
* `ENVIRONMENT` — Environmental effects (such as flooding) has prevented the vessel from functioning.

```protobuf
enum VesselStatus {
	TRANSIT = 0;
	LOADING = 1;
	SERVICING = 2;
	EMERGENCY = 3;
	INACTIVE = 4;
}
```
Status code describing the general state of the vessel:
* `TRANSIT` — The vessel is moving to its next step along its set route.
* `LOADING` — The vessel is stopped at its designated stop in its route.
* `SERVICING` — The vessel is active but is not moving along its route. Usually happens if the vessel is moving to and fro its depot.
* `EMERGENCY` — The vessel has encountered an emergency.
* `INACTIVE` — The vessel is inactive. Usually happens when the vessel is parked/docked in its depot.

```protobuf
message Setting {
	string name = 1;
	string value = 2;
}
```

#### [`0`] Notice*
Response message: Ack

Notices are sent from server to client or client to server. The usual behavior of the client upon receiving a server notice is to display it on-screen.

```protobuf
message Notice {
	uint32 message_id = 1;
	Timestamp time_generated = 2;
	Severity severity = 3;
	string details = 4;
}
```

#### [`2`] Ping
Response message: Ack

Notes:

* Although this uses a message ID, this is not re-sent in case of failure.
* The sender may pad the packet with more bytes than the actual size of the ping data (but the `payload_size` must be kept to the size of the actual payload) in order to discover the actual MTU. It is recommended to do this only when the need to send more than 576 bytes of data arises.

```protobuf
message Ping {
	uint32 message_id = 1;
	Timestamp time_generated = 2;
}
```

* `time_generated` — time this Ping message is generated.

#### [`3`] Ack
Response to: Ping, ModifyServerKeys, ChangeSettings

```protobuf
message Ack {
	uint32 message_id = 1;
	Timestamp time_generated = 2;
}
```

* `message_id` — should be identical to the message it's responding to.
* `time_generated` — time the Ack message is generated.

### Unencrypted Messages
These messages have payloads that are unencrypted but signed using `crypto_sign*`. The `nonce`, `mac`, and `reserved` entries in the payload header form the message signature.

#### [`10`] Crypto Error
Sent whenever there's a cryptography-related error that occurred, usually due to wrong keys or tampering of data.

```protobuf
message CryptoError {
	string details = 1;	
}
```

#### [`11`] Modify Server Keys*
Response message: Ack

Sent by the master server instructing clients to modify their server key database. Unlike other messages, this is not signed by the server key, but by the master key.

```protobuf
message ModifyServerKeys {
	enum Operation {
		UPSERT = 0;
		DELETE = 1;
	}

	uint32 message_id = 1;
	Timestamp time_issued = 2;
	Operation operation = 3;
	uint32 server_id = 4;
	bytes public_key = 5;
}
```

* `time_issued` — time the server key modification happened. This is NOT when the packet is sent. This field should be used to order the modification events.
* `server_id` — server of the key to modify.

### Client Messages
#### [`20`] Location Update
```protobuf
message LocationUpdate {
	message Entry {
		Timestamp ts = 1;
		float longitude = 2;
		float latitude = 3;
		float bearing = 4;
		float speed = 5;
		int32 current_load = 6;
		VesselStatus status = 7;
		uint32 current_trip_id = 8;
		uint32 stop = 9;
	};
	repeated Entry entries = 1;
}
```

Multiple location update entries may be sent in a LocationUpdateMessage as long as it's under the MTU.

* `entries` — Location update entries, must be sorted from earliest to latest.
* `current_load` — current number of passengers if applicable. Use `-1` if the value is unavailable.
* `current_trip_id` — ID of the trip the vessel is currently in. Use `0` if the trip in unknown or unavailable.
* `stop` — ID of the current stop (if `status = LOADING`), or the next stop (if `status = TRANSIT`). Use `0` if the stop is unknown or unavailable.

#### [`21`] Trip Info Update Status
Response to: Trip Info Update

Sent:
1. The moment a Trip Update server message is sent.
2. Every minute that a Trip Update is being downloaded.
3. When the Trip Update is done.

```protobuf
message TripInfoUpdateStatus {
	enum Status {
		IN_PROGRESS = 0;
		DONE = 1;
		ERROR = 2;
	}
	uint32 update_id = 1;
	Status status = 2;
}
```

* `update_id` — ID of the TripInfoUpdate this message is responding to.

### Server Messages
#### [`50`] Change Settings*
Response message: Ack

If the total ChangeSettings payload exceeds 540 bytes, the settings list must be split and sent separately.
Setting string values are formatted according to the JSON protobuf mapping stated [here](https://developers.google.com/protocol-buffers/docs/proto3#json).
Currently, possible settings are:

|   name       |              type        |
|--------------|--------------------------|
| UpdatePeriod | google.protobuf.Duration |

```protobuf
message ChangeSettings {
	uint32 message_id = 1;
	repeated Setting settings = 2;
}
```

#### [`51`] Error Response
```protobuf
message Error {
	enum Reason {
		PAYLOAD_SIZE_MISMATCH = 0;
		PAYLOAD_PARSE_FAIL = 1;
		INVALID_MESSAGE_TYPE = 2;
		INVALID_SETTING_VALUES = 3;
	}
	Reason code = 1;
	uint32 message_id = 2;
	string details = 3;
}
```

* `message_id` — The message ID the error is responding to, if available. If the message has no ID, this value is 0.

#### [`52`] ETA Update
```protobuf
message ETAUpdate {
	Timestamp server_timestamp = 1;
	Duration time_remaining = 2;
	double meters_left = 3;
	float percentage_completed = 4;
}
```

* `server_timestamp` - time the ETA update was generated.
* `time_remaining` — estimated time remaining in the trip, use this with `server_timestamp` to compute the current remaining time in the client.
* `percentage_completed` — value from 0 to 1 with 0 being the start of the trip and 1 being the end of the trip.

#### [`53`] Trip Info Update*
Response message: Trip Info Update Status

Requests the client to download trip update data over HTTP/S using the specified URL.
```protobuf
message TripInfoUpdate {
	uint32 update_id = 1;
	Timestamp request_date = 2;
	string url = 3;
}
```